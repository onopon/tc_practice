# テストコードとは

あるロジックを書いた時に、その**ロジックの整合性を担保する**ためのコードのことを言います。

ロジックの仕様をコード化するようなイメージです。

# なぜテストコードが必要なのか？

色々理由はありますが、最も大きな理由は **<span style="color:#d70910;">エンジニアの心理的安全性を保つため</span>** と考えます。

エンジニアにとって怖いもの。それは、

### バグ

デプロイ時、誰しもバグってないかどうかは不安になるものです。

### 機能改修の依頼

機能改修を依頼されたとしましょう。

例えばそれが1行直すだけの簡単な修正だったとしても、その機能がいろんなところで活用されるようなものだった場合について考えてみましょう。

影響範囲が膨大なものとなり、予期していない箇所が実はエラーとなってしまっているみたいな状況にもなりかねません。

---

こういった状況は、全てではないものの大部分はテストコードで打破することができるようになります。

テストコードが存在していれば、どこかを直したタイミングで全然関係ない機能が壊れてしまうことに気づくことができるため、バグを未然に防ぐことが可能となります。

また、ロジックを読んでもメソッドの挙動がわからない場合でも、テストコードを読むことでどのような使い方をすれば良いのかが理解でき、正しく自分以外の誰かが書いたメソッドを利用することができるようになります。

# テストコードの利用タイミング

## レビュー依頼を投げるタイミング

　先にも書いた通り、エンジニアはバグの無いコードをデプロイしたいものです。

そのため、プロジェクトにもよりますが、基本的には、レビュー依頼を投げるタイミング(githubへpushするタイミング)で全てのテストが実行されるように設定されているかと思います。

## 手動でチェック

もちろんローカルでもチェックできます。

pushタイミングでは、全てのチェックをしないといけないので、存在するテストの分だけ時間がかかってしまいます。

個人でチェックする際は、1ファイルに絞ったり、1テストに絞って実行することができるので、開発中は今書いてるテストだけを実行していくとストレスなく開発を進めることができます。

# テストコードの特徴

### テストコードのファイル名は xxxxxxTest.php

例えば、 User.php というコードに該当するテストを書く場合、ファイル名は**UserTest.php** となります。

### テストコードは通常のロジックとは異なるpathに配置する

テストコードは通常のロジックが置かれるpathとは別のディレクトリに置かれます。

本リポジトリでは `tests` というpathになっています。
  
### テストディレクトリにロジックコードと対になるpathを用意する

Laravelはtests配下にFeature Unitにディレクトリが用意されています。

それぞれ下記の役割を持っています。

- Feature: Controllers Commandsといった1連の流れのテストを置きます。
- Unit: ModelsやLibrariesなどの単体のテストを置きます。

例えば app/Models/User.php のテストコードの置き場所は tests/Unit/Models/UserTest.php となります。

# テストコードの実行の流れ

tests pathにあるTestファイルを順次実行していきます。

1ファイル内のテストケースを実行する際、毎テスト前後にsetUp() 、tearDown() メソッドが呼ばれます。

それぞれ下記の役割を持っています。

- setUp: ファイル内の全テストで必ず実行したい事前処理
- tearDown: ファイル内の全テストで必ず実行したい事後処理

ex)

testA, testBのテスト実行時は

setUp -> testA -> tearDown -> setUp -> testB -> tearDown

という順番でメソッドが実行されていきます。

# テストコードを書く上でのポイント

## 1テストケースでのコンテキスト（文脈）を明確にする

必ずしも1メソッド1テストケースになるとは限りません。

1つのメソッドに対して、考え得る条件を一つ一つテストケースとして作成するよう心がけましょう。

例えば、 app/Models/User.php はユーザをloginIdとpasswordを利用して探す findWith というメソッドを持っています。

このテストケースとして考え得るケースは、

- ユーザが見つかる
- ユーザが見つからない
- ユーザが見つかるが、パスワードが違う

の3ケースとなります。

## 1メソッドのコードを完結にする

先述の通り、1メソッドに対して考え得る挙動の数だけテストケースを書く必要があります。

そのため、1メソッドが長ければ長いほど、テストケースがどんどん増加したり、書きづらくなってしまいます。

1メソッドのコードは完結にまとめるように心がけましょう。

## DBのデータは1テストケース毎に削除する

基本的には他のテストケースに影響を及ぼさない形で終わらせた方が良いです。

（影響を及ぼす形で終わらせたい場合もありますが、その際は書き方がちゃんと用意されています。）

DBのデータに関しても同じことが言えます。

テーブルに何かしらゴミデータが残るような状態だと、「単体で実行した時には通るのに、全てのテストを1から順番に実行していくとこけてしまう」みたいな状況になりかねません。

テスト終了時（tearDown時）に使ったデータは全部消えるようにしておきましょう。

Laravelでは、テストケース開始時にtransactionを貼り、テスト終了後にrollbackをすることでテストケース毎にデータは削除される挙動となっています。

## DBのデータを作成する際は、極力idはauto incrementに頼る

テストコードは、あくまで実際に利用された際の挙動を担保するために存在するものです。
なので、マスターデータ（そのデータがないとサービスが運用できないようなデータ）のような決められた値以外のものはauto incrementでinsertしましょう。

本リポジトリでは、 database/seeders/RoleSeeder.php により作られるレコードは、マスターデータのため、idが変わらないように設定しています。

## 必ず通るテストを書く

気づかないうちに、低確率で落ちたり、時間的な条件を満たしていないと時限式で落ちてしまうテストコードを書いてしまうことがあるので注意しましょう。

#### 落ちてしまう可能性がある例

```php
// 今年が2023年でない限り通らない
$this->assertEquals($date->getThisYear(), 2023);
```

#### 治し方のアイディア

```php
// intが返ってくることを期待する
$this->assertInt($date->getThisYear());

// Carbonを使って時間を止める
Carbon::setTestNow(Carbon::createFromDate(2023, 1, 13));
$this->assertEquals($date->getThisYear(), 2023);
```

## 外部ネットワークにアクセスしない

テストはネットワークがない環境でも動作するように書いていきましょう。

例えば

- APIを叩いて取得してきたデータを利用したい
- メールを送信したい

など、外部に何かしらのアクションを行いたい場面は出てきます。

しかし、外部ネットワークを利用してしまうと、メンテなどでAPIが死んでる場合にテストがこけたり、毎テスト実行時にメールが飛び交ったりなどいろんなことが想定されます。

その際は、mock（モック）して対応しましょう。

詳しい説明は割愛しますが、mockを利用すると、「(実際には叩かないけど）このAPIを叩いたとしたらこういう結果が返ってくるよね」という結果だけ作って、その後のロジックで利用できるようになったりします。

メール送信なども、「（実際には送信されないけど）何回メール送信メソッドが呼ばれたよ」みたいな情報に変えられるので、それらを利用してテストを進めていきます。


### モックの仕方

外部メソッドを叩く際、本プロジェクトではGuzzleを活用しています。

テスト時はMockeryを使うことで、「実際にAPIは叩かないけど、もしそのAPIを叩いたらこのような形でデータが返ってくる」みたいな仮想データを代わりに返すことができます。

具体的な使い方は下記の様な形です。

mockの具体例や使い方は下記URLを参考にしてみてください。

https://readouble.com/mockery/1.0/ja/quick_reference.html
